package chapter08;


import java.io.*;

/*
 * 8.1 자바의 입출력 스트림
 * 
 * 		스트림 입출력이란?
 * 
 * 컴퓨터 공학에서 스트림은 연속적인 데이터의 흐름 혹은 데이터의 흐름 혹은 데이터를 전송하는 소프트웨어 모듈을
 * 일컫는데. 시냇물에 띄어진 종이배가 순서대로 흘러가듯이 컴퓨터에서 스트림은 도착한 순서대로 데이터를 흘러
 * 보낸다.
 * 
 * 자바에서 입출력 스트림은 응용 프로그램과 입출력 장치를 연결하는 소프트웨어 모듈이다. 그림에서 응용 프로그램은
 * 입력스트림과 연결하며, 입력 스트림은 키보드 장치를 제어하여 사용자의 키 입력을 받아 응용프로그램에게 전달한다.
 * 또한 응용프로그램은 출력 스트림에 연결하고 출력 스트림에 출력하면, 출력 스트림은 다른 끝단에 연결된 출력 장치를 
 * 제어하여 출력을 완성한다.
 * 
 * 스트림 입출력 방식에서, 자바 응용 프로그램은 입출력 장치를 직접 제어하는 대신, 입출력 스트림 객체와 연결하여 쉽게
 * 데이터 입출력을 실행한다.
 * 
 * 스트림을 사용하지 않고 자바 응용프로그램이 입출력 장치를 직접 제어하는 코드를 작성하여 입출력을 실행하려 한다면, 응용
 * 프로그램 작성이 매우 어렵고, 하드웨어 구조나 제어가 다양한 입출력 장치를 모두 수용할 수 없게 될 것이다.
 * 
 * 
 * 			입출력 스트림의 특징
 * 
 * 
 *    * 스트림의 양 끝에는 입출력 장치와 자바 응용프로그램이 연결된다.
 *   	
 *   	자바 응용프로그램은 입력 스트림과 출력 스트림과만 연결하고, 입출력 스트림이 입출력 장치를 제어하고 실질적인
 *   	입출력을 담당한다.
 *   
 *   
 *    * 스트림은 단방향이다.
 *   	
 *   	입력 스트림은 입력 장치에서 응용프로그램으로 데이터를 전송하며, 출력 스트림은 응용프로그램으로부터 받은 데이터를 출력 장치로
 *   	전송한다. 두 가지 기능을 모두 가진 스트림은 없다.
 *   
 *    * 스트림을 통해 흘러가는 기본 단위는 바이트나 문자이다.
 *   
 *   	자바의 스트림 객체는 바이트를 단위로 입출력하는 바이트 스트림과 문자 단위로 입출력하는 문자 스트림으로 나뉜다.
 *   
 *    * 스트림은 선입선출, 즉 FIFO 구조이다.
 * 
 * 
 * 
 * 
 * 			바이트 스트림과 문자 스트림
 * 
 * 
 * 
 * 	자바에서 입출력 스트림은 '문자 스트림'(character stream)과 '바이트 스트림'(byte stream)의 2종류로 나뉜다.
 * 문자 스트림은 문자만 다룬기 때문에, 문자가 아닌 데이터가 출력되면 보이지 않거나 엉뚱한 기호가 출력되며, 문자가 아닌
 * 정보가 입력되면 응용프로그램에게 엉뚱한 문자가 전달되는 오류가 발생한다. 참고로 자바에서 char 타입, 즉 문자의 하나의
 * 크기는 2바이트이다.
 * 
 *  
 * 한편, 바이트 스트림은 바이트를 단위로 다루는 스트림으로, 스트림에 들어오고 나가는 정보를 단순 바이너리(비트들)로 다루기 때문에,
 * 문자든 이미지 바이트든 상관없이 흘러보낸다.
 * 
 * 
 * 
 * 이러한 응용프로그램들은 전부 java.io 패키지에 포함되어 있다. 바이트 스트림을 다루는 클래스는 공통적으로 이름 뒤에 'Stream'을
 * 붙이고, 문자 스트림을 다루는 클래스는 Reader/Writer를 붙여 구분한다.
 * 
 * 메모장으로 작성된 텍스트 파일이나 자바 소스 파일 같이 문자들로만 이루어진 파일을 읽고 쓰는 경우, 문자 스트림 클래스(FileReader, FileWriter)
 * 나 바이트 스트림 클래스(FileInputStream, FileOutputStream) 모두 사용이 가능하짐나, 이미지나 비디오 등 외의 파일의 데이터는 문자가 아닌
 * 바이너리 정보들이므로, 이들을 읽거나 쓰는 경우 반드시 바이트 스트림 클래스(FileInputStream, FileOutputStream)를 이용해야 한다.
 * 
 * 
 * 
 * 
 * 			스트림 연결
 * 
 * 
 * 스트림은 서로 연결될 수 있다. 쿠키를 만드는 시스템이 있을 때, 우리가 밀가루를 넣어서 반죽을 만드는 시스템이 있고, 그 반죽을 쿠키로 만드는
 * 시스템이 있다. 이렇게 2개의 스트림이 있다.
 * 
 * 자바 응용프로그램에서 바이트 스트림과 문자 스트림을 이용하여 사용해보자. 다음은 키보드로부터 문자를 입력받기 위해 표준 입력 스트림인 System.in
 * 과 InputStreamReader 스트림 객체를 '연결'하는 코드이다.
 * 
 * 
 * InputStreamReader rd=new InputStreamReader(System.in);
 * 
 * 
 * 
 * 이 코드는 문자 스트림 rd를 생성하고 ,키보드와 연결된 표준 입력 스트림인 System.in을 연결한다. System.in은 InputSteam 타입으로 바이트
 * 입력 스트림이다. 이렇데 두 스트림이 연결되면, System.in은 사용자의 키 입력을 받아 바이트 스트림으로 내보내며, rd는 들어오는 바이트 스트림을
 * 문자로 구성하여 응용프로그램에게 전달한다. 자바 응용프로그램은 다음과 같이 rd.read()를 통해 사용자가 입력한 문자를 읽을 수 있다.
 * 
 * 
 * int c=rd.read();
 * 
 * 
 * 
 * 예를 들어, 사용자가 'a','?' 키를 순서대로 입력하면 System.in은 a와 ? 키를 읽고 바이트 정보를 내보낸다. rd는 연속적으로 들어오는 바이트들은
 * 문자로 변환하고 'a','?' 문자를 응용프로그램에게 전달해 준다. 스트림은 몇개라도 가능하다.
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	8.2 문자 스트림과 파일 입출력
 * 
 * 
 * 		문자 스트림 클래스
 * 
 * 
 * 문자 스트림은 '2바이트의 유니코드 문자'를 단위로 입출력하는 스트림이다. 문자화되지 않는 바이너리 바이트 값들은 문자 스트림 클래스에서 처리할 수 없다. 
 * 따라서 이미지와 같은 바이너리 바이트 값들은 문자 스트림 클래스에서 처리할 수 없다. 문자 입력 스트림은 바잍들을 전달받고, 이 바이트들은 '로컬 문자 집합'
 * 에 있는 문자인지 비교하며 문자로 변환한다. 만일 '로컬 문자 집합'에서 찾을 수 없는 경우, 문자가 아니거나 다른 언어의 문자들 혹은 문자 집합이 잘못 설정되어
 * 있는 경우이다. 이제, 문자 스트림 클래스를 보자.
 * 
 * 
 * 
 * 	FileReader를 이용한 텍스트 파일 읽기
 * 
 * <표8-1>와 <표8-2>는 텍스트 파일을 읽는데 사용되는 FileReader 클래스의 생성자와 메소드를 보여준다.
 * 
 * 		
 * 
 * 
 * 		*파일 입력 스트림 생성
 * 
 * 먼저 파일 입력 스트림을 생성하고 스트림을 파일과 연결한다. 다음은 FileReader로 파일 입력 스트림을 생성하고, c:\test.txt 파일을 연결하는 코드이다.
 * 
 * 
 * 		FileReader fin=new FileReader("c:\\test.txt");
 * 
 * FileReader의 생성자는 C:\test.txt 파일을 찾아 열고, 파일과 스트림을 연결한다. C:\test.txt 파일은 문자들로만 구성된 텍스트 파일이다.
 * 
 * 
 * 
 * 
 * 		* 파일 읽기 
 * 
 * 이제 파일 입력 스트림(fin)을 이용하여 파일을 읽어보자. fin.read()는 연결된 파일로부터 문자 하나를 읽어 리턴하여, 파일의 끝(EOF)을 만나면
 * -1을 리턴한다. fin.read()를 이용하여 파일 전체를 읽어 화면에 출력하는 코드는 다음과 같다.
 * 
 * 
 * 		int c;
 * 
 * 	while((c=fin.read())!=-1)
 * 	{	System.out.println((char)c);}
 * 
 * 
 * 
 * c=fin.read()에서 문자를 읽는데 왜 char 타입이 아닌, int 타입의 변수 c를 사용하는지 궁금하다. 이는 다음에 적혀있다.
 * 파일이 큰 경우 한 번에 한 문자씩 읽으면 릭는 속도가 너무 느리기 때문에, 다음과 같이 한 번에 한 블록(버퍼 크기)만큼 읽는
 * read()를 이용하면 된다.
 * 
 * 
 * char[] buf=new char[1024]; // 1024는 1KB이다.
 * 
 * int n=fin.read(buf); // 한번에 1024개의 문자를 읽어 buf[]에 저장하고 실제 읽은 문자수 리턴
 * 
 * 
 * 
 * 버퍼란 읽고 쓸 데이터를 저장하는 배열을 부르는 용어이다. 이 코드에서 파일에 남아 있는 문자의 수가 1024개 보다 작을 때, read()는
 * 실제로 읽은 문자의 개수를 리턴한다. 그러므로 n과 버퍼의 크기인 1024를 비교하여 n이 작다면, 파일의 끝까지 읽은 것으로 판단하면 된다.
 * 
 * 
 * 
 * 
 * 
 * 		* 스트림 닫기
 * 
 * 
 * 파일 읽기가 더 이상 필요없어지면 다음과 같이 close() 메서드를 이용하여 파일 입력 스트림을 닫는다. 닫힌 스트림으로부터는 더 이상 읽을
 * 수가 없다.
 * 
 * 
 * fin.close();
 * 
 * 
 * 
 * <표 8-1>
 * 
 * ------------------------------------------------------------------------------------------------------------
 * 			생성사			|									설명
 * ------------------------------------------------------------------------------------------------------------
 * 	FileReader(File file)	|	file로부터 읽는 FileReader 생성
 * ------------------------------------------------------------------------------------------------------------
 * 	FileReader(String name) | name 이름의 파일로부터 읽는 FileReader 생성
 * ------------------------------------------------------------------------------------------------------------
 * 
 * 
 * 
 * 
 * 
 * <표 8-2> (FileReader, Reader, InputStreamReader의 공통 주요 메서드)
 * ------------------------------------------------------------------------------------------------------------
 * 	int read()										| 한 개의 문자를 읽어 정수형으로 리턴
 * ------------------------------------------------------------------------------------------------------------
 * 	int read(char []cbuf)   						| 문자들을 일거 cbuf 배열에 저장하고 읽은 개수 리턴
 * ------------------------------------------------------------------------------------------------------------
 *  int read(char[] cbuf, int off,int len)			| 최대 len 개수의 문자들을 읽어 cbuf 배열의 off 위치부터 저장하고 실제 읽은
 *  												| 위치부터 저장하고 실제 읽은 개수 리턴
 *  -----------------------------------------------------------------------------------------------------------
 *  String getEncoding()							| 스트림이 사용하는 문자 집합의 이름 리턴
 *  -----------------------------------------------------------------------------------------------------------
 *  void close()									| 입력 스트림을 닫고 관련된 시스템 자원 해제
 *  -----------------------------------------------------------------------------------------------------------
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  			파일 입출력과 예외 처리
 *  
 *  
 *  파일 입출력 실행 중 예외가 발생할 수 있다. 첫째, 파일의 경로명이 틀린 경우, FileReader 생성자는 FileNotFoundException 예외를 발생시킨다.
 *  
 *  FiledReader fin=new FileReader("c:\\test.txt");		// FileNotFoundException 발생 가능
 *  
 *  
 *  둘째, 파일 읽기, 쓰기, 닫기를 하는 동안 입출력 오류가 발생하면, read(), write(), close() 메서드는 IOException 예외를 발생시킨다.
 *  
 *  		int c=fin.read(); //IOException 발생 가능
 *  
 *  
 *  
 *  그러므로 파일 입출력 코드에 다음과 같은 try-catch 블록이 필요하다.
 *  
 *  
 *  try{
 *  
 *  	FileReader fin=new FileReader("c:\\test.txt");
 *  
 *  	..
 *  	int c=new fin.read();
 *  	..
 *  	fin.close();
 *  
 *  	} catch(FileNotFoundException e){
 *  
 *  	System.out.println("파일을 열 수 없음.");
 *  
 *  	}catch(IOEXception e){
 *  	System.out.println("입출력 오류");
 *  	}
 *  
 * 
 *   
 * 
 * 
 * 
 * */


// Page. 452
// Filereader를 이용하여 system.ini 파일을 읽어 화면에 출력하는 프로그램을 작성하라.
public class FileReaderEx {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		FileReader fin=null;
		
		try{
			fin=new FileReader("c:\\windows\\system.ini");
			
			int c;
			
			while((c=fin.read())!=-1){
				System.out.print((char)c);
			}
			fin.close();
		}
		catch(IOException e){
			System.out.println("입출력 오류");
		}
	}

}


/*
 * 
 * 
 * 
 * 			문자 집합과 InputStreamReader를 이용한 텍스트 파일 읽기
 * 
 * 
 * 
 * InputStreamReader는 스트림에 입력된느 바이트 데이터를 문자 집합을 통해 문자로
 * 변환한다. 이를 위해 InputStreamReader의 생성자에 문자 집합을 지정해야 한다.
 * 만일 읽어들인 바이트들이 문자 집합에 속하지 않은 경우 해독할 수 없는 글자가 된다.
 * 
 *
 * 예제 8-2는 InputStreamREader에 문자 집합을 지정하고 텍스트 파일을 읽는 예를
 * 보인다. InputStreamReader 클래스의 생성자는 <표 8-3>과 같고, 메소드는 FileReader
 * 와 동일하게 <표 8-2>와 같다.
 * 
 * 
 * 
 * 
 * <표 8-3>	InputStreamReader 생성자
 * 
 * ---------------------------------------------------------------------------------------------------
 * 	InputStreamReader(InputStream in) 					| in으로부터 읽는 기본 문자 집합의 InputStreamReader 생성
 * ---------------------------------------------------------------------------------------------------
 * 	InputStreamReader(InputStream in, Charset cs)		| in으로부터 읽는 cs문자 집합의 InputStreamReader 생성
 * ---------------------------------------------------------------------------------------------------
 * 	InputStreamReader(InputStream in, String charsetName) | in으로부터 읽는 charsetName 문자 집합의 
 * 														  | InputStreamReader 생성
 * ---------------------------------------------------------------------------------------------------
 * 
 * 
 * 
 * 
 * 	* InputStreamReader 문자 입력 스트림 생성
 * 
 * InputStreamReader는 바이트 스트림을 전달받아 문자 정보로 변환하는 스트림 객체이다. 그러므로 우선 텍스트 파일을 읽기 위해서는
 * 다음과 같이 바이트 파일 입력 스트림을 먼저 생성한다.
 * 
 * 
 * 		FileInputStream in=new FileInputStream("c:\\Temp\\hangul.txt");
 * 
 * 
 * 
 * 
 * 
 * 여기서 c:\Temp\hangul.txt는 메모장으로 작성한 한글 텍스트 파일이다. 그러나 나서, 다음과 같이 InputStreamReader 객체를
 * 생성한다.
 * 
 * 
 * 		InputStreamReader in=new InputStreamReader(fin,"MS949");
 * 
 * 
 * 
 * 
 * 
 * 생성자 InputStreamReader()의 두 번째 매개변수는 fin으로부터 읽어 들인 바이트들을 문자로 인코딩하기 위한 집합을 지정한다.
 * 생성자에 MS949 문자 집합을 지정하였다.
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 		* 파일 읽기
 * 
 * 
 * 스트림이 연결된 모양은 밑의 체계를 따른다.
 * 
 * 
 * ( c:\Temp\hangul.txt)   --->     fin			----> 		in				-----> in.read()
 * (	로 미리 작성.     )		(FileInputStream)     	(InputStreamReader)
 * 
 * 
 * 
 * 
 * 
 * */
